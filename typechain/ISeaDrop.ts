/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export type PublicDropStruct = {
  mintPrice: BigNumberish;
  startTime: BigNumberish;
  endTime: BigNumberish;
  maxTotalMintableByWallet: BigNumberish;
  feeBps: BigNumberish;
  restrictFeeRecipients: boolean;
};

export type PublicDropStructOutput = [
  BigNumber,
  number,
  number,
  number,
  number,
  boolean
] & {
  mintPrice: BigNumber;
  startTime: number;
  endTime: number;
  maxTotalMintableByWallet: number;
  feeBps: number;
  restrictFeeRecipients: boolean;
};

export type SignedMintValidationParamsStruct = {
  minMintPrice: BigNumberish;
  maxMaxTotalMintableByWallet: BigNumberish;
  minStartTime: BigNumberish;
  maxEndTime: BigNumberish;
  maxMaxTokenSupplyForStage: BigNumberish;
  minFeeBps: BigNumberish;
  maxFeeBps: BigNumberish;
};

export type SignedMintValidationParamsStructOutput = [
  BigNumber,
  number,
  number,
  number,
  number,
  number,
  number
] & {
  minMintPrice: BigNumber;
  maxMaxTotalMintableByWallet: number;
  minStartTime: number;
  maxEndTime: number;
  maxMaxTokenSupplyForStage: number;
  minFeeBps: number;
  maxFeeBps: number;
};

export type TokenGatedDropStageStruct = {
  mintPrice: BigNumberish;
  maxTotalMintableByWallet: BigNumberish;
  startTime: BigNumberish;
  endTime: BigNumberish;
  dropStageIndex: BigNumberish;
  maxTokenSupplyForStage: BigNumberish;
  feeBps: BigNumberish;
  restrictFeeRecipients: boolean;
};

export type TokenGatedDropStageStructOutput = [
  BigNumber,
  number,
  number,
  number,
  number,
  number,
  number,
  boolean
] & {
  mintPrice: BigNumber;
  maxTotalMintableByWallet: number;
  startTime: number;
  endTime: number;
  dropStageIndex: number;
  maxTokenSupplyForStage: number;
  feeBps: number;
  restrictFeeRecipients: boolean;
};

export type MintParamsStruct = {
  mintPrice: BigNumberish;
  maxTotalMintableByWallet: BigNumberish;
  startTime: BigNumberish;
  endTime: BigNumberish;
  dropStageIndex: BigNumberish;
  maxTokenSupplyForStage: BigNumberish;
  feeBps: BigNumberish;
  restrictFeeRecipients: boolean;
};

export type MintParamsStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  boolean
] & {
  mintPrice: BigNumber;
  maxTotalMintableByWallet: BigNumber;
  startTime: BigNumber;
  endTime: BigNumber;
  dropStageIndex: BigNumber;
  maxTokenSupplyForStage: BigNumber;
  feeBps: BigNumber;
  restrictFeeRecipients: boolean;
};

export type TokenGatedMintParamsStruct = {
  allowedNftToken: string;
  allowedNftTokenIds: BigNumberish[];
};

export type TokenGatedMintParamsStructOutput = [string, BigNumber[]] & {
  allowedNftToken: string;
  allowedNftTokenIds: BigNumber[];
};

export type AllowListDataStruct = {
  merkleRoot: BytesLike;
  publicKeyURIs: string[];
  allowListURI: string;
};

export type AllowListDataStructOutput = [string, string[], string] & {
  merkleRoot: string;
  publicKeyURIs: string[];
  allowListURI: string;
};

export interface ISeaDropInterface extends utils.Interface {
  functions: {
    "getAllowListMerkleRoot(address)": FunctionFragment;
    "getAllowedFeeRecipients(address)": FunctionFragment;
    "getAllowedNftTokenIdIsRedeemed(address,address,uint256)": FunctionFragment;
    "getCreatorPayoutAddress(address)": FunctionFragment;
    "getFeeRecipientIsAllowed(address,address)": FunctionFragment;
    "getPayerIsAllowed(address,address)": FunctionFragment;
    "getPayers(address)": FunctionFragment;
    "getPublicDrop(address)": FunctionFragment;
    "getSignedMintValidationParams(address,address)": FunctionFragment;
    "getSigners(address)": FunctionFragment;
    "getTokenGatedAllowedTokens(address)": FunctionFragment;
    "getTokenGatedDrop(address,address)": FunctionFragment;
    "mintAllowList(address,address,address,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool),bytes32[])": FunctionFragment;
    "mintAllowedTokenHolder(address,address,address,(address,uint256[]))": FunctionFragment;
    "mintPublic(address,address,address,uint256)": FunctionFragment;
    "mintSigned(address,address,address,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool),uint256,bytes)": FunctionFragment;
    "updateAllowList((bytes32,string[],string))": FunctionFragment;
    "updateAllowedFeeRecipient(address,bool)": FunctionFragment;
    "updateCreatorPayoutAddress(address)": FunctionFragment;
    "updateDropURI(string)": FunctionFragment;
    "updatePayer(address,bool)": FunctionFragment;
    "updatePublicDrop((uint80,uint48,uint48,uint16,uint16,bool))": FunctionFragment;
    "updateSignedMintValidationParams(address,(uint80,uint24,uint40,uint40,uint40,uint16,uint16))": FunctionFragment;
    "updateTokenGatedDrop(address,(uint80,uint16,uint48,uint48,uint8,uint32,uint16,bool))": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "getAllowListMerkleRoot"
      | "getAllowedFeeRecipients"
      | "getAllowedNftTokenIdIsRedeemed"
      | "getCreatorPayoutAddress"
      | "getFeeRecipientIsAllowed"
      | "getPayerIsAllowed"
      | "getPayers"
      | "getPublicDrop"
      | "getSignedMintValidationParams"
      | "getSigners"
      | "getTokenGatedAllowedTokens"
      | "getTokenGatedDrop"
      | "mintAllowList"
      | "mintAllowedTokenHolder"
      | "mintPublic"
      | "mintSigned"
      | "updateAllowList"
      | "updateAllowedFeeRecipient"
      | "updateCreatorPayoutAddress"
      | "updateDropURI"
      | "updatePayer"
      | "updatePublicDrop"
      | "updateSignedMintValidationParams"
      | "updateTokenGatedDrop"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "getAllowListMerkleRoot",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllowedFeeRecipients",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllowedNftTokenIdIsRedeemed",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCreatorPayoutAddress",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getFeeRecipientIsAllowed",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getPayerIsAllowed",
    values: [string, string]
  ): string;
  encodeFunctionData(functionFragment: "getPayers", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getPublicDrop",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getSignedMintValidationParams",
    values: [string, string]
  ): string;
  encodeFunctionData(functionFragment: "getSigners", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getTokenGatedAllowedTokens",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenGatedDrop",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "mintAllowList",
    values: [
      string,
      string,
      string,
      BigNumberish,
      MintParamsStruct,
      BytesLike[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "mintAllowedTokenHolder",
    values: [string, string, string, TokenGatedMintParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "mintPublic",
    values: [string, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "mintSigned",
    values: [
      string,
      string,
      string,
      BigNumberish,
      MintParamsStruct,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateAllowList",
    values: [AllowListDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateAllowedFeeRecipient",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "updateCreatorPayoutAddress",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateDropURI",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updatePayer",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "updatePublicDrop",
    values: [PublicDropStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateSignedMintValidationParams",
    values: [string, SignedMintValidationParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenGatedDrop",
    values: [string, TokenGatedDropStageStruct]
  ): string;

  decodeFunctionResult(
    functionFragment: "getAllowListMerkleRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllowedFeeRecipients",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllowedNftTokenIdIsRedeemed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCreatorPayoutAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFeeRecipientIsAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPayerIsAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getPayers", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getPublicDrop",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSignedMintValidationParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getSigners", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getTokenGatedAllowedTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenGatedDrop",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintAllowList",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintAllowedTokenHolder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mintPublic", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mintSigned", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateAllowList",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateAllowedFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateCreatorPayoutAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateDropURI",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updatePayer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updatePublicDrop",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateSignedMintValidationParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenGatedDrop",
    data: BytesLike
  ): Result;

  events: {
    "AllowListUpdated(address,bytes32,bytes32,string[],string)": EventFragment;
    "AllowedFeeRecipientUpdated(address,address,bool)": EventFragment;
    "CreatorPayoutAddressUpdated(address,address)": EventFragment;
    "DropURIUpdated(address,string)": EventFragment;
    "PayerUpdated(address,address,bool)": EventFragment;
    "PublicDropUpdated(address,(uint80,uint48,uint48,uint16,uint16,bool))": EventFragment;
    "SeaDropMint(address,address,address,address,uint256,uint256,uint256,uint256)": EventFragment;
    "SignedMintValidationParamsUpdated(address,address,(uint80,uint24,uint40,uint40,uint40,uint16,uint16))": EventFragment;
    "TokenGatedDropStageUpdated(address,address,(uint80,uint16,uint48,uint48,uint8,uint32,uint16,bool))": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AllowListUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowedFeeRecipientUpdated"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "CreatorPayoutAddressUpdated"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DropURIUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PayerUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PublicDropUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SeaDropMint"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "SignedMintValidationParamsUpdated"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenGatedDropStageUpdated"): EventFragment;
}

export interface AllowListUpdatedEventObject {
  nftContract: string;
  previousMerkleRoot: string;
  newMerkleRoot: string;
  publicKeyURI: string[];
  allowListURI: string;
}
export type AllowListUpdatedEvent = TypedEvent<
  [string, string, string, string[], string],
  AllowListUpdatedEventObject
>;

export type AllowListUpdatedEventFilter =
  TypedEventFilter<AllowListUpdatedEvent>;

export interface AllowedFeeRecipientUpdatedEventObject {
  nftContract: string;
  feeRecipient: string;
  allowed: boolean;
}
export type AllowedFeeRecipientUpdatedEvent = TypedEvent<
  [string, string, boolean],
  AllowedFeeRecipientUpdatedEventObject
>;

export type AllowedFeeRecipientUpdatedEventFilter =
  TypedEventFilter<AllowedFeeRecipientUpdatedEvent>;

export interface CreatorPayoutAddressUpdatedEventObject {
  nftContract: string;
  newPayoutAddress: string;
}
export type CreatorPayoutAddressUpdatedEvent = TypedEvent<
  [string, string],
  CreatorPayoutAddressUpdatedEventObject
>;

export type CreatorPayoutAddressUpdatedEventFilter =
  TypedEventFilter<CreatorPayoutAddressUpdatedEvent>;

export interface DropURIUpdatedEventObject {
  nftContract: string;
  newDropURI: string;
}
export type DropURIUpdatedEvent = TypedEvent<
  [string, string],
  DropURIUpdatedEventObject
>;

export type DropURIUpdatedEventFilter = TypedEventFilter<DropURIUpdatedEvent>;

export interface PayerUpdatedEventObject {
  nftContract: string;
  payer: string;
  allowed: boolean;
}
export type PayerUpdatedEvent = TypedEvent<
  [string, string, boolean],
  PayerUpdatedEventObject
>;

export type PayerUpdatedEventFilter = TypedEventFilter<PayerUpdatedEvent>;

export interface PublicDropUpdatedEventObject {
  nftContract: string;
  publicDrop: PublicDropStructOutput;
}
export type PublicDropUpdatedEvent = TypedEvent<
  [string, PublicDropStructOutput],
  PublicDropUpdatedEventObject
>;

export type PublicDropUpdatedEventFilter =
  TypedEventFilter<PublicDropUpdatedEvent>;

export interface SeaDropMintEventObject {
  nftContract: string;
  minter: string;
  feeRecipient: string;
  payer: string;
  quantityMinted: BigNumber;
  unitMintPrice: BigNumber;
  feeBps: BigNumber;
  dropStageIndex: BigNumber;
}
export type SeaDropMintEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  SeaDropMintEventObject
>;

export type SeaDropMintEventFilter = TypedEventFilter<SeaDropMintEvent>;

export interface SignedMintValidationParamsUpdatedEventObject {
  nftContract: string;
  signer: string;
  signedMintValidationParams: SignedMintValidationParamsStructOutput;
}
export type SignedMintValidationParamsUpdatedEvent = TypedEvent<
  [string, string, SignedMintValidationParamsStructOutput],
  SignedMintValidationParamsUpdatedEventObject
>;

export type SignedMintValidationParamsUpdatedEventFilter =
  TypedEventFilter<SignedMintValidationParamsUpdatedEvent>;

export interface TokenGatedDropStageUpdatedEventObject {
  nftContract: string;
  allowedNftToken: string;
  dropStage: TokenGatedDropStageStructOutput;
}
export type TokenGatedDropStageUpdatedEvent = TypedEvent<
  [string, string, TokenGatedDropStageStructOutput],
  TokenGatedDropStageUpdatedEventObject
>;

export type TokenGatedDropStageUpdatedEventFilter =
  TypedEventFilter<TokenGatedDropStageUpdatedEvent>;

export interface ISeaDrop extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ISeaDropInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    getAllowListMerkleRoot(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getAllowedFeeRecipients(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getAllowedNftTokenIdIsRedeemed(
      nftContract: string,
      allowedNftToken: string,
      allowedNftTokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getCreatorPayoutAddress(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getFeeRecipientIsAllowed(
      nftContract: string,
      feeRecipient: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getPayerIsAllowed(
      nftContract: string,
      payer: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getPayers(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getPublicDrop(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<[PublicDropStructOutput]>;

    getSignedMintValidationParams(
      nftContract: string,
      signer: string,
      overrides?: CallOverrides
    ): Promise<[SignedMintValidationParamsStructOutput]>;

    getSigners(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getTokenGatedAllowedTokens(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getTokenGatedDrop(
      nftContract: string,
      allowedNftToken: string,
      overrides?: CallOverrides
    ): Promise<[TokenGatedDropStageStructOutput]>;

    mintAllowList(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      mintParams: MintParamsStruct,
      proof: BytesLike[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    mintAllowedTokenHolder(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      mintParams: TokenGatedMintParamsStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    mintPublic(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    mintSigned(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      mintParams: MintParamsStruct,
      salt: BigNumberish,
      signature: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateAllowList(
      allowListData: AllowListDataStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateAllowedFeeRecipient(
      feeRecipient: string,
      allowed: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateCreatorPayoutAddress(
      payoutAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateDropURI(
      dropURI: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updatePayer(
      payer: string,
      allowed: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updatePublicDrop(
      publicDrop: PublicDropStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateSignedMintValidationParams(
      signer: string,
      signedMintValidationParams: SignedMintValidationParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateTokenGatedDrop(
      allowedNftToken: string,
      dropStage: TokenGatedDropStageStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  getAllowListMerkleRoot(
    nftContract: string,
    overrides?: CallOverrides
  ): Promise<string>;

  getAllowedFeeRecipients(
    nftContract: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  getAllowedNftTokenIdIsRedeemed(
    nftContract: string,
    allowedNftToken: string,
    allowedNftTokenId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getCreatorPayoutAddress(
    nftContract: string,
    overrides?: CallOverrides
  ): Promise<string>;

  getFeeRecipientIsAllowed(
    nftContract: string,
    feeRecipient: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getPayerIsAllowed(
    nftContract: string,
    payer: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getPayers(nftContract: string, overrides?: CallOverrides): Promise<string[]>;

  getPublicDrop(
    nftContract: string,
    overrides?: CallOverrides
  ): Promise<PublicDropStructOutput>;

  getSignedMintValidationParams(
    nftContract: string,
    signer: string,
    overrides?: CallOverrides
  ): Promise<SignedMintValidationParamsStructOutput>;

  getSigners(nftContract: string, overrides?: CallOverrides): Promise<string[]>;

  getTokenGatedAllowedTokens(
    nftContract: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  getTokenGatedDrop(
    nftContract: string,
    allowedNftToken: string,
    overrides?: CallOverrides
  ): Promise<TokenGatedDropStageStructOutput>;

  mintAllowList(
    nftContract: string,
    feeRecipient: string,
    minterIfNotPayer: string,
    quantity: BigNumberish,
    mintParams: MintParamsStruct,
    proof: BytesLike[],
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  mintAllowedTokenHolder(
    nftContract: string,
    feeRecipient: string,
    minterIfNotPayer: string,
    mintParams: TokenGatedMintParamsStruct,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  mintPublic(
    nftContract: string,
    feeRecipient: string,
    minterIfNotPayer: string,
    quantity: BigNumberish,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  mintSigned(
    nftContract: string,
    feeRecipient: string,
    minterIfNotPayer: string,
    quantity: BigNumberish,
    mintParams: MintParamsStruct,
    salt: BigNumberish,
    signature: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateAllowList(
    allowListData: AllowListDataStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateAllowedFeeRecipient(
    feeRecipient: string,
    allowed: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateCreatorPayoutAddress(
    payoutAddress: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateDropURI(
    dropURI: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updatePayer(
    payer: string,
    allowed: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updatePublicDrop(
    publicDrop: PublicDropStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateSignedMintValidationParams(
    signer: string,
    signedMintValidationParams: SignedMintValidationParamsStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateTokenGatedDrop(
    allowedNftToken: string,
    dropStage: TokenGatedDropStageStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    getAllowListMerkleRoot(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<string>;

    getAllowedFeeRecipients(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getAllowedNftTokenIdIsRedeemed(
      nftContract: string,
      allowedNftToken: string,
      allowedNftTokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getCreatorPayoutAddress(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<string>;

    getFeeRecipientIsAllowed(
      nftContract: string,
      feeRecipient: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getPayerIsAllowed(
      nftContract: string,
      payer: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getPayers(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getPublicDrop(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<PublicDropStructOutput>;

    getSignedMintValidationParams(
      nftContract: string,
      signer: string,
      overrides?: CallOverrides
    ): Promise<SignedMintValidationParamsStructOutput>;

    getSigners(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getTokenGatedAllowedTokens(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getTokenGatedDrop(
      nftContract: string,
      allowedNftToken: string,
      overrides?: CallOverrides
    ): Promise<TokenGatedDropStageStructOutput>;

    mintAllowList(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      mintParams: MintParamsStruct,
      proof: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    mintAllowedTokenHolder(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      mintParams: TokenGatedMintParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    mintPublic(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    mintSigned(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      mintParams: MintParamsStruct,
      salt: BigNumberish,
      signature: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    updateAllowList(
      allowListData: AllowListDataStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    updateAllowedFeeRecipient(
      feeRecipient: string,
      allowed: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    updateCreatorPayoutAddress(
      payoutAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    updateDropURI(dropURI: string, overrides?: CallOverrides): Promise<void>;

    updatePayer(
      payer: string,
      allowed: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    updatePublicDrop(
      publicDrop: PublicDropStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    updateSignedMintValidationParams(
      signer: string,
      signedMintValidationParams: SignedMintValidationParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    updateTokenGatedDrop(
      allowedNftToken: string,
      dropStage: TokenGatedDropStageStruct,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AllowListUpdated(address,bytes32,bytes32,string[],string)"(
      nftContract?: string | null,
      previousMerkleRoot?: BytesLike | null,
      newMerkleRoot?: BytesLike | null,
      publicKeyURI?: null,
      allowListURI?: null
    ): AllowListUpdatedEventFilter;
    AllowListUpdated(
      nftContract?: string | null,
      previousMerkleRoot?: BytesLike | null,
      newMerkleRoot?: BytesLike | null,
      publicKeyURI?: null,
      allowListURI?: null
    ): AllowListUpdatedEventFilter;

    "AllowedFeeRecipientUpdated(address,address,bool)"(
      nftContract?: string | null,
      feeRecipient?: string | null,
      allowed?: boolean | null
    ): AllowedFeeRecipientUpdatedEventFilter;
    AllowedFeeRecipientUpdated(
      nftContract?: string | null,
      feeRecipient?: string | null,
      allowed?: boolean | null
    ): AllowedFeeRecipientUpdatedEventFilter;

    "CreatorPayoutAddressUpdated(address,address)"(
      nftContract?: string | null,
      newPayoutAddress?: string | null
    ): CreatorPayoutAddressUpdatedEventFilter;
    CreatorPayoutAddressUpdated(
      nftContract?: string | null,
      newPayoutAddress?: string | null
    ): CreatorPayoutAddressUpdatedEventFilter;

    "DropURIUpdated(address,string)"(
      nftContract?: string | null,
      newDropURI?: null
    ): DropURIUpdatedEventFilter;
    DropURIUpdated(
      nftContract?: string | null,
      newDropURI?: null
    ): DropURIUpdatedEventFilter;

    "PayerUpdated(address,address,bool)"(
      nftContract?: string | null,
      payer?: string | null,
      allowed?: boolean | null
    ): PayerUpdatedEventFilter;
    PayerUpdated(
      nftContract?: string | null,
      payer?: string | null,
      allowed?: boolean | null
    ): PayerUpdatedEventFilter;

    "PublicDropUpdated(address,(uint80,uint48,uint48,uint16,uint16,bool))"(
      nftContract?: string | null,
      publicDrop?: null
    ): PublicDropUpdatedEventFilter;
    PublicDropUpdated(
      nftContract?: string | null,
      publicDrop?: null
    ): PublicDropUpdatedEventFilter;

    "SeaDropMint(address,address,address,address,uint256,uint256,uint256,uint256)"(
      nftContract?: string | null,
      minter?: string | null,
      feeRecipient?: string | null,
      payer?: null,
      quantityMinted?: null,
      unitMintPrice?: null,
      feeBps?: null,
      dropStageIndex?: null
    ): SeaDropMintEventFilter;
    SeaDropMint(
      nftContract?: string | null,
      minter?: string | null,
      feeRecipient?: string | null,
      payer?: null,
      quantityMinted?: null,
      unitMintPrice?: null,
      feeBps?: null,
      dropStageIndex?: null
    ): SeaDropMintEventFilter;

    "SignedMintValidationParamsUpdated(address,address,(uint80,uint24,uint40,uint40,uint40,uint16,uint16))"(
      nftContract?: string | null,
      signer?: string | null,
      signedMintValidationParams?: null
    ): SignedMintValidationParamsUpdatedEventFilter;
    SignedMintValidationParamsUpdated(
      nftContract?: string | null,
      signer?: string | null,
      signedMintValidationParams?: null
    ): SignedMintValidationParamsUpdatedEventFilter;

    "TokenGatedDropStageUpdated(address,address,(uint80,uint16,uint48,uint48,uint8,uint32,uint16,bool))"(
      nftContract?: string | null,
      allowedNftToken?: string | null,
      dropStage?: null
    ): TokenGatedDropStageUpdatedEventFilter;
    TokenGatedDropStageUpdated(
      nftContract?: string | null,
      allowedNftToken?: string | null,
      dropStage?: null
    ): TokenGatedDropStageUpdatedEventFilter;
  };

  estimateGas: {
    getAllowListMerkleRoot(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAllowedFeeRecipients(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAllowedNftTokenIdIsRedeemed(
      nftContract: string,
      allowedNftToken: string,
      allowedNftTokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCreatorPayoutAddress(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFeeRecipientIsAllowed(
      nftContract: string,
      feeRecipient: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPayerIsAllowed(
      nftContract: string,
      payer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPayers(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPublicDrop(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSignedMintValidationParams(
      nftContract: string,
      signer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSigners(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTokenGatedAllowedTokens(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTokenGatedDrop(
      nftContract: string,
      allowedNftToken: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mintAllowList(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      mintParams: MintParamsStruct,
      proof: BytesLike[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    mintAllowedTokenHolder(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      mintParams: TokenGatedMintParamsStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    mintPublic(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    mintSigned(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      mintParams: MintParamsStruct,
      salt: BigNumberish,
      signature: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    updateAllowList(
      allowListData: AllowListDataStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateAllowedFeeRecipient(
      feeRecipient: string,
      allowed: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateCreatorPayoutAddress(
      payoutAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateDropURI(
      dropURI: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updatePayer(
      payer: string,
      allowed: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updatePublicDrop(
      publicDrop: PublicDropStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateSignedMintValidationParams(
      signer: string,
      signedMintValidationParams: SignedMintValidationParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateTokenGatedDrop(
      allowedNftToken: string,
      dropStage: TokenGatedDropStageStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    getAllowListMerkleRoot(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAllowedFeeRecipients(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAllowedNftTokenIdIsRedeemed(
      nftContract: string,
      allowedNftToken: string,
      allowedNftTokenId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCreatorPayoutAddress(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFeeRecipientIsAllowed(
      nftContract: string,
      feeRecipient: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPayerIsAllowed(
      nftContract: string,
      payer: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPayers(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPublicDrop(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSignedMintValidationParams(
      nftContract: string,
      signer: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSigners(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTokenGatedAllowedTokens(
      nftContract: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTokenGatedDrop(
      nftContract: string,
      allowedNftToken: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    mintAllowList(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      mintParams: MintParamsStruct,
      proof: BytesLike[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    mintAllowedTokenHolder(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      mintParams: TokenGatedMintParamsStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    mintPublic(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    mintSigned(
      nftContract: string,
      feeRecipient: string,
      minterIfNotPayer: string,
      quantity: BigNumberish,
      mintParams: MintParamsStruct,
      salt: BigNumberish,
      signature: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateAllowList(
      allowListData: AllowListDataStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateAllowedFeeRecipient(
      feeRecipient: string,
      allowed: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateCreatorPayoutAddress(
      payoutAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateDropURI(
      dropURI: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updatePayer(
      payer: string,
      allowed: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updatePublicDrop(
      publicDrop: PublicDropStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateSignedMintValidationParams(
      signer: string,
      signedMintValidationParams: SignedMintValidationParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateTokenGatedDrop(
      allowedNftToken: string,
      dropStage: TokenGatedDropStageStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
